/* Copyright 2022 Mithril Security. All rights reserved.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License. */

syntax = "proto3";
package remote_torch;

message ReferenceRequest {
    bytes hash = 1;
}

message ReferenceResponse {
    bytes hash = 1;
    string name = 2;
    string description = 3;
    License license = 4;
    bytes meta = 5;
}

message RunRequest {
    string uuid = 1;
}

message RunResponse {
    string uuid = 1;
    bytes model = 2;
    bytes dataset = 3;
}

message Chunk {
    bytes data = 1;
    string name = 2;
    string description = 3;
    License license = 4;
    bytes meta = 5;
    ClientInfo client_info = 6;
}

message Empty {}

message TrainRequest {
    bytes model = 1;
    bytes dataset = 2;
    int32 batch_size = 3;
    int32 epochs = 4;
    string device = 5;
    string metric = 6;
    float eps = 7;
    float max_grad_norm = 8;
    float metric_eps = 9;
    int32 per_n_steps_checkpoint = 12;
    int32 per_n_epochs_checkpoint = 13;
    bool resume = 14;
    ClientInfo client_info = 15;
    
    oneof optimizer {
        // The type of optimizer to be used during training.
        // Currently, only SGD and Adam are supported.
        SGD sgd = 10;
        Adam adam = 11;
    }

    message SGD {
        // SGD optimizer object.

        float learning_rate = 1;
        float weight_decay = 2;
        float momentum = 3;
        float dampening = 4;
        bool nesterov = 5;
    }

    message Adam {
        // Adam optimizer object.

        float learning_rate = 1;
        float beta_1 = 2;
        float beta_2 = 3;
        float epsilon = 4;
        float weight_decay = 5;
        bool amsgrad = 6;
    }
}

message TestRequest {
    bytes model = 1;
    bytes dataset = 2;
    int32 batch_size = 3;
    string device = 4;
    string metric = 5;
    float metric_eps = 6;
    ClientInfo client_info = 7;
}

message ReferenceListResponse {
    repeated ReferenceResponse list = 1;
}

message ListResponse {
    repeated string list = 1;
}

message MetricResponse {
    float value = 1;
    float uncertainty = 2;
    int32 batch = 3;
    int32 epoch = 4;
    int32 nb_epochs = 5;
    int32 nb_batches = 6;
}

message ClientInfo {
    string uid = 1;
    string platform_name = 2;
    string platform_arch = 3;
    string platform_version = 4;
    string platform_release = 5;
    string user_agent = 6;
    string user_agent_version = 7;
}

message ChallengeResponse {
    bytes value = 1;
}

service RemoteTorch {
    rpc SendDataset (stream Chunk) returns (ReferenceResponse) {}
    rpc SendModel (stream Chunk) returns (ReferenceResponse) {}
    rpc FetchDataset (ReferenceRequest) returns (stream Chunk) {}
    rpc FetchModel (ReferenceRequest) returns (stream Chunk) {}
    rpc FetchCheckpoint (ReferenceRequest) returns (stream Chunk) {}
    rpc FetchRun (ReferenceRequest) returns (ReferenceResponse) {}
    rpc DeleteDataset (ReferenceRequest) returns (Empty) {}
    rpc DeleteModel (ReferenceRequest) returns (Empty) {}
    rpc DeleteCheckpoint (ReferenceRequest) returns (Empty) {}
    rpc DeleteRun (ReferenceRequest) returns (Empty) {}
    rpc AvailableModels(Empty) returns (ReferenceListResponse) {}
    rpc AvailableDatasets(Empty) returns (ReferenceListResponse) {}
    rpc AvailableCheckpoints(Empty) returns (ReferenceListResponse) {}
    rpc AvailableDevices(Empty) returns (ListResponse) {}
    rpc AvailableOptimizers(Empty) returns (ListResponse) {}
    rpc Train (TrainRequest) returns (ReferenceResponse) {}
    rpc Test (TestRequest) returns (ReferenceResponse) {}
    rpc GetMetric (ReferenceRequest) returns (MetricResponse) {}
    rpc GetChallenge (Empty) returns (ChallengeResponse) {}
}

message Rule {
    message AtLeastNOf {
        uint64 n = 1;
        repeated Rule rules = 2;
    }
    oneof rule {
        AtLeastNOf at_least_n_of = 1;
        // This is a hash
        bytes with_checkpoint = 2;
        // This is a hash
        bytes with_dataset = 3;
        // This is a DER-encoded SubjectPublicKeyInfo ECDSA_P256_SHA256_ASN1 pubkey
        bytes signed_with = 4;
    }
}

message ResultStrategy {
    enum Strategy {
        Checkpoint = 0;
        Dataset = 1;
        And = 2;
        Or = 3;
        Custom = 4;
    }
    Strategy strategy = 1;
    // This field is present iff `strategy` == `Strategy::Custom`
    License custom_license = 2;
}

message License {
    Rule train = 1;
    Rule test = 2;
    Rule list = 3;
    Rule fetch = 4;
    Rule delete = 5;
    ResultStrategy result_strategy = 6;
}